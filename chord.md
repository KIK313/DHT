# chord report
## chord 基本思想
#### $\text{chord}$ 利用 $\text{sha1}$ 这种一致性哈希的方法将结点的地址和数据的 $\text{key}$ 值映射成160位的大整数， 称为 $\text{ID}$, 结点根据 $\text{ID}$ 由小到大的顺序形成一个环结构，我们规定从小走到大的方向为顺时针。而数据存储在 $\text{ID}$ 沿顺时针走遇到的第一个节点上，并在该结点的后继结点存储备份。为了查找的效率，每个结点不仅要维护环上的前驱和后继结点，还要维护 $(ID+2^i)$ $mod$ $2^{160}$ 这个值沿环顺时针走遇到的第一个结点， 形成所谓的 $\text{Finger Table}$ ,这里其实运用了倍增的思想， 当然随着结点的加入和退出，环结构的维护以及数据的迁移都不是一件容易的事，所以我们需要保存额外的后继信息 $\text{Success List}$ 并且时刻进行检查来保证 $\text{chord}$ 结构的基本正确
## 我的设计

## 技术细节
#### (1) 在执行结点 $\text{Quit}$ 的时候会修改该结点前驱的后继以及该结点后继的前驱，但是，这三个结点的检查函数会使修改操作失效，因此可以利用加锁的方法不让检查函数和退出函数同时发生
#### (2)对于 $\text{Finger Table}$ 中 $\text{Ping}$ 不通的结点，可以直接置为空，之后就不会多次 $\text{Ping}$ 这样可以减小时间的开销，并且在 $\text{Fix Finger Table}$ 函数中能做到有的放矢
## 调试问题
### 1. rpc相关的网络产生的问题
#### (1) $\text{RemoteCall}$ 结束后 $\text{client}$ 没有关闭
#### (2) $\text{listener}$ 在结点下线后没有关闭
#### (3) 因为结点下线后 $\text{listener.accept()}$ 被阻塞, 该问题和 $\text{(2)}$ 一起解决
#### (4) 因为结点 $\text{RunRpcServer}$ 没有正常关闭，所以 $\text{conn}$ 没有被自动关闭，会产生问题，需要手动关闭 $\text{conn}$
### 2. go 语言特性产生的问题
#### (1) 结构体名字的首字母没有大写， 无法作为参数类型
#### (2) 结构体中有指针类型但直接用未定义的等号赋值
#### (3) 一开始在外部调用函数时没有解锁，导致函数内部加锁后出现了死锁的问题
### 3. 写法问题
#### (1) 在 $\text{Join}$ 时一开始没有转移数据，产生了问题
#### (2) 一开始为图方便用 $\text{ForceQuit}$ 来代替 $\text{Quit}$ 函数， 但是发现在快速退出的时候结点信息更新不够快，只好重新写

