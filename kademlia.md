# kademlia report
## kademlia 基本思想
kademlia 也是利用一致性哈希的方法将结点的地址和信息的 key 映射到160位的哈希值，并且将数据存储在离该数据最近的 k 个结点上。kademlia 最精彩的地方是它采用异或对距离进行度量。dis(x,y) = x ^ y, 其中 x , y 是160位的二进制数。我们发现这种距离是满足度量空间的要求的。而对于寻找离数据最近的k个结点的操作叫做 lookup 。这个操作是基于找到一个结点知道的离数据最近的k个结点（findnode），然后通过若干次的搜索得到全局离数据最近的k的结点。

此外 kademlia 有一定的排外性，比起将老结点替换为新结点， kademlia 会更乐意保留老结点。这样做的原因是基于数据统计，发现老结点更加可靠。这种做法在一定程度上可以抵抗外部的攻击。
## 设计
对每个结点维护160 个 k-bucket，编号为 0-159，其中第 i 的 k-bucket 中的结点满足和当前结点的哈希值从高位到低位第一个二进制位不同是第 i 位，这样利用 k-bucket 可以快速找到一个结点知道的离数据最近的 k 个结点。
随着新结点的加入和原结点的退出，对于一个数据，离它最近的 k 个结点会发生很大的变化，所以对数据要定期 republish。
## 技术细节
在 findnode 过程中尽量保证找到的结点都是在线的，这样可以使一次 findnode 找的信息更有效。
## 调试问题
### 主体上是写法问题
#### (1) 一开始没有过多结点之间的连边，结点之间的联系较少，导致 lookup 的一致性不强。后来会在在 republish 后进行连边，效果较好。
#### (2) 面对下线问题，结点的 bucket 更新不及时。 后来额外开进程定期维护 bucket 的信息，这样 bucket 信息有效性得到一定的保证。